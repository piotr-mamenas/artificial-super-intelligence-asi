/**
 * Inversion Engine - The Core of the Symmetry-Inversion AI
 * 
 * KEY INSIGHT: Inversions form a waveform.
 * - Each inversion creates an oscillation
 * - Sequence of inversions = wave pattern
 * - Successful inversions = manifested reality
 * - Failed inversions = black holes / voids
 * 
 * The AI LEARNS by finding inverses.
 * The RENDERING shows what has been successfully inverted (manifested).
 */

import { v4 as uuidv4 } from 'uuid';

// ============================================
// FUNDAMENTAL: The Inversion Operation
// ============================================

/**
 * An invertible element - anything that can be inverted.
 */
export interface Invertible {
  id: string;
  value: Float32Array;      // The "content" - what this represents
  inverse: Invertible | null; // Its inverse (if known)
  isManifested: boolean;    // Has this been successfully inverted (understood)?
  depth: number;            // How many inversions deep
}

/**
 * Result of attempting an inversion.
 */
export interface InversionResult {
  success: boolean;
  original: Invertible;
  inverted: Invertible | null;
  error: number;            // How far from perfect inversion (0 = perfect)
  waveContribution: number; // Amplitude contribution to the wave
}

/**
 * The waveform generated by a sequence of inversions.
 */
export interface InversionWave {
  id: string;
  amplitudes: number[];     // Wave amplitude at each time step
  phases: number[];         // Phase at each time step  
  frequency: number;        // Dominant frequency
  manifestedRegions: ManifestRegion[]; // Where inversions succeeded
  voidRegions: VoidRegion[];           // Where inversions failed (black holes)
}

/**
 * A region of manifested reality (successful inversions).
 */
export interface ManifestRegion {
  id: string;
  center: [number, number, number]; // 3D position
  radius: number;
  intensity: number;        // How "solid" - based on inversion confidence
  color: [number, number, number]; // RGB derived from inversion pattern
  sourceInversions: string[]; // IDs of inversions that created this
}

/**
 * A void region (failed inversions = black hole).
 */
export interface VoidRegion {
  id: string;
  center: [number, number, number];
  radius: number;
  depth: number;            // How "deep" the void goes
  failedAttempts: number;   // How many inversion attempts failed here
}

// ============================================
// THE INVERSION ENGINE
// ============================================

export interface InversionEngine {
  // State
  currentWave: InversionWave;
  inversionHistory: InversionResult[];
  manifestedReality: ManifestRegion[];
  voids: VoidRegion[];
  
  // Core operations
  invert(element: Invertible): InversionResult;
  doubleInvert(element: Invertible): InversionResult; // Invert twice = identity?
  
  // Wave operations
  tick(dt: number): void;
  getWaveAmplitude(t: number): number;
  getWavePhase(t: number): number;
  
  // Manifestation
  updateManifestation(): void;
  getManifestedRegions(): ManifestRegion[];
  getVoidRegions(): VoidRegion[];
  
  // Learning
  learnInverse(element: Invertible, proposedInverse: Invertible): number; // Returns error
}

/**
 * Create the inversion engine.
 */
export function createInversionEngine(dimension: number = 16): InversionEngine {
  const id = uuidv4();
  
  // The wave generated by inversions
  const currentWave: InversionWave = {
    id: uuidv4(),
    amplitudes: [],
    phases: [],
    frequency: 1.0,
    manifestedRegions: [],
    voidRegions: []
  };
  
  const inversionHistory: InversionResult[] = [];
  const manifestedReality: ManifestRegion[] = [];
  const voids: VoidRegion[] = [];
  
  let time = 0;
  let waveAccumulator = 0;
  
  /**
   * Attempt to invert an element.
   * Inversion means: find X⁻¹ such that X · X⁻¹ = identity
   */
  function invert(element: Invertible): InversionResult {
    // If inverse is already known, use it
    if (element.inverse) {
      const error = calculateInversionError(element, element.inverse);
      const contribution = error < 0.1 ? 1.0 : Math.exp(-error);
      
      return {
        success: error < 0.3,
        original: element,
        inverted: element.inverse,
        error,
        waveContribution: contribution
      };
    }
    
    // Try to compute inverse
    const proposedInverse = computeInverse(element);
    const error = calculateInversionError(element, proposedInverse);
    const success = error < 0.3;
    
    if (success) {
      // Link them as inverses
      element.inverse = proposedInverse;
      proposedInverse.inverse = element;
      element.isManifested = true;
      proposedInverse.isManifested = true;
    }
    
    const result: InversionResult = {
      success,
      original: element,
      inverted: success ? proposedInverse : null,
      error,
      waveContribution: success ? Math.cos(time * currentWave.frequency) : 0
    };
    
    inversionHistory.push(result);
    
    // Update wave based on this inversion
    updateWaveFromInversion(result);
    
    return result;
  }
  
  /**
   * Double inversion: X⁻¹⁻¹ should equal X (identity).
   * This is the test of true understanding.
   */
  function doubleInvert(element: Invertible): InversionResult {
    const first = invert(element);
    if (!first.success || !first.inverted) {
      return first;
    }
    
    const second = invert(first.inverted);
    
    // Check if we got back to the original
    const returnError = calculateReturnError(element, second.inverted);
    
    return {
      success: returnError < 0.1, // Stricter threshold for double inversion
      original: element,
      inverted: second.inverted,
      error: returnError,
      waveContribution: second.waveContribution * (returnError < 0.1 ? 2 : 0.5)
    };
  }
  
  /**
   * Compute the inverse of an element.
   */
  function computeInverse(element: Invertible): Invertible {
    // Inversion = negate and normalize
    const inverted = new Float32Array(element.value.length);
    let norm = 0;
    
    for (let i = 0; i < element.value.length; i++) {
      // Inversion through origin: negate
      inverted[i] = -element.value[i];
      norm += inverted[i] * inverted[i];
    }
    
    // Normalize
    norm = Math.sqrt(norm);
    if (norm > 0) {
      for (let i = 0; i < inverted.length; i++) {
        inverted[i] /= norm;
      }
    }
    
    return {
      id: uuidv4(),
      value: inverted,
      inverse: null, // Will be linked after successful inversion
      isManifested: false,
      depth: element.depth + 1
    };
  }
  
  /**
   * Calculate how far from perfect inversion (X · X⁻¹ = 0).
   */
  function calculateInversionError(a: Invertible, b: Invertible): number {
    // Perfect inversion: dot product should be -1 (opposite directions)
    let dot = 0;
    const len = Math.min(a.value.length, b.value.length);
    
    for (let i = 0; i < len; i++) {
      dot += a.value[i] * b.value[i];
    }
    
    // Error is distance from -1
    return Math.abs(dot + 1);
  }
  
  /**
   * Calculate if double inversion returns to original.
   */
  function calculateReturnError(original: Invertible, returned: Invertible | null): number {
    if (!returned) return Infinity;
    
    let error = 0;
    const len = Math.min(original.value.length, returned.value.length);
    
    for (let i = 0; i < len; i++) {
      const diff = original.value[i] - returned.value[i];
      error += diff * diff;
    }
    
    return Math.sqrt(error);
  }
  
  /**
   * Update the wave based on an inversion result.
   */
  function updateWaveFromInversion(result: InversionResult): void {
    // Each inversion contributes to the wave
    const amplitude = result.success ? result.waveContribution : -result.error;
    const phase = time * currentWave.frequency * 2 * Math.PI;
    
    currentWave.amplitudes.push(amplitude);
    currentWave.phases.push(phase);
    
    // Keep history bounded
    if (currentWave.amplitudes.length > 1000) {
      currentWave.amplitudes.shift();
      currentWave.phases.shift();
    }
    
    waveAccumulator += amplitude;
  }
  
  /**
   * Tick the engine forward.
   */
  function tick(dt: number): void {
    time += dt;
    
    // Wave naturally oscillates
    const naturalOscillation = Math.sin(time * currentWave.frequency * 2 * Math.PI);
    
    // Combine with accumulated inversions
    const currentAmplitude = naturalOscillation * (1 + waveAccumulator * 0.1);
    
    currentWave.amplitudes.push(currentAmplitude);
    currentWave.phases.push(time * currentWave.frequency * 2 * Math.PI);
    
    // Decay accumulator
    waveAccumulator *= 0.99;
    
    // Update manifestation based on wave
    updateManifestation();
  }
  
  /**
   * Get wave amplitude at time t.
   */
  function getWaveAmplitude(t: number): number {
    const idx = Math.floor(t) % Math.max(1, currentWave.amplitudes.length);
    return currentWave.amplitudes[idx] ?? 0;
  }
  
  /**
   * Get wave phase at time t.
   */
  function getWavePhase(t: number): number {
    return (t * currentWave.frequency * 2 * Math.PI) % (2 * Math.PI);
  }
  
  /**
   * Update what's manifested based on inversion success.
   */
  function updateManifestation(): void {
    // Group successful inversions into manifested regions
    const successfulInversions = inversionHistory.filter(r => r.success);
    
    // Clear and rebuild (simple approach)
    manifestedReality.length = 0;
    voids.length = 0;
    currentWave.manifestedRegions = [];
    currentWave.voidRegions = [];
    
    // Create manifested regions from successful inversions
    for (let i = 0; i < successfulInversions.length; i++) {
      const inv = successfulInversions[i];
      
      // Position based on the inversion's value (first 3 components)
      const x = inv.original.value[0] ?? 0;
      const y = inv.original.value[1] ?? 0;
      const z = inv.original.value[2] ?? 0;
      
      // Intensity based on how good the inversion was
      const intensity = 1 - inv.error;
      
      // Color from the value pattern
      const r = Math.abs(inv.original.value[3] ?? 0.5);
      const g = Math.abs(inv.original.value[4] ?? 0.5);
      const b = Math.abs(inv.original.value[5] ?? 0.5);
      
      const region: ManifestRegion = {
        id: uuidv4(),
        center: [x * 5, y * 5, z * 5], // Scale up for visibility
        radius: 0.1 + intensity * 0.4,
        intensity,
        color: [r, g, b],
        sourceInversions: [inv.original.id]
      };
      
      manifestedReality.push(region);
      currentWave.manifestedRegions.push(region);
    }
    
    // Create void regions from failed inversions
    const failedInversions = inversionHistory.filter(r => !r.success);
    
    for (let i = 0; i < failedInversions.length; i++) {
      const inv = failedInversions[i];
      
      const x = inv.original.value[0] ?? 0;
      const y = inv.original.value[1] ?? 0;
      const z = inv.original.value[2] ?? 0;
      
      const voidRegion: VoidRegion = {
        id: uuidv4(),
        center: [x * 5, y * 5, z * 5],
        radius: 0.2 + inv.error * 0.3,
        depth: inv.error,
        failedAttempts: 1
      };
      
      voids.push(voidRegion);
      currentWave.voidRegions.push(voidRegion);
    }
  }
  
  /**
   * Learn an inverse relationship.
   */
  function learnInverse(element: Invertible, proposedInverse: Invertible): number {
    const error = calculateInversionError(element, proposedInverse);
    
    if (error < 0.3) {
      element.inverse = proposedInverse;
      proposedInverse.inverse = element;
      element.isManifested = true;
      proposedInverse.isManifested = true;
      
      // Successful learning contributes positively to wave
      waveAccumulator += 1 - error;
    } else {
      // Failed learning creates a void
      waveAccumulator -= error;
    }
    
    return error;
  }
  
  return {
    currentWave,
    inversionHistory,
    manifestedReality,
    voids,
    
    invert,
    doubleInvert,
    
    tick,
    getWaveAmplitude,
    getWavePhase,
    
    updateManifestation,
    getManifestedRegions: () => manifestedReality,
    getVoidRegions: () => voids,
    
    learnInverse
  };
}

/**
 * Create a random invertible element.
 */
export function createRandomInvertible(dimension: number = 16): Invertible {
  const value = new Float32Array(dimension);
  let norm = 0;
  
  for (let i = 0; i < dimension; i++) {
    value[i] = Math.random() * 2 - 1;
    norm += value[i] * value[i];
  }
  
  // Normalize
  norm = Math.sqrt(norm);
  for (let i = 0; i < dimension; i++) {
    value[i] /= norm;
  }
  
  return {
    id: uuidv4(),
    value,
    inverse: null,
    isManifested: false,
    depth: 0
  };
}

/**
 * Create an invertible from specific values.
 */
export function createInvertible(values: number[]): Invertible {
  const value = new Float32Array(values);
  let norm = 0;
  
  for (let i = 0; i < value.length; i++) {
    norm += value[i] * value[i];
  }
  
  norm = Math.sqrt(norm);
  if (norm > 0) {
    for (let i = 0; i < value.length; i++) {
      value[i] /= norm;
    }
  }
  
  return {
    id: uuidv4(),
    value,
    inverse: null,
    isManifested: false,
    depth: 0
  };
}
